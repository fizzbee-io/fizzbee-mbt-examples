// Code generated by fizzbee-mbt generator; DO NOT EDIT.

// Import the generated traits, adapters, and framework utilities
use super::traits::*;
use super::adapters::{new_counter_model, get_test_options};

use fizzbee_mbt::traits::*;
use fizzbee_mbt::types::*;
use fizzbee_mbt::value::*;
use fizzbee_mbt::error::MbtError;
use async_trait::async_trait;

/// The Dispatcher routes actions from the MBT framework to the correct Role/Model instance.
/// It wraps the concrete Model implementation.
pub struct CounterActionDispatcher<T>
where
    T: CounterModel + Send + Sync + 'static,
{
    // The concrete model instance is owned directly
    model: Option<T>,
}

#[async_trait]
impl<T> Model for CounterActionDispatcher<T>
where
    T: Model + CounterModel + Send + Sync + 'static,
{
    /// Delegates initialization to the inner model instance.
    async fn init(&mut self) -> Result<(), MbtError> {
        self.model.as_mut().ok_or_else(|| MbtError::other("Model not found"))?
            .init().await
    }

    /// Delegates cleanup to the inner model instance.
    async fn cleanup(&mut self) -> Result<(), MbtError> {
        self.model.as_mut().ok_or_else(|| MbtError::other("Model not found"))?
            .cleanup().await
    }
}

impl<T> CounterActionDispatcher<T>
where
    T: CounterModel + Send + Sync + 'static,
{
    pub fn new(model: T) -> Self {
        CounterActionDispatcher {
            model: Some(model),
        }
    }
}

/// Implementation of the framework's core execution contract (`DispatchModel`).
#[async_trait]
impl<T> DispatchModel for CounterActionDispatcher<T>
where
    T: CounterModel,
    T: Send + Sync + 'static,
{
    async fn execute(
        &self,
        role_id: &RoleId,
        function_name: &str,
        args: &[Arg],
    ) -> Result<Value, MbtError> {

        let inner_model_ref = self.model.as_ref().ok_or_else(|| {
            MbtError::other("Model is not initialized or has been moved out of the dispatcher.")
        })?;

        match role_id.role_name.as_str() {
            // Role actions
            
            "Counter" => {
                let index = role_id.index as usize;
                
                let roles_vec = inner_model_ref.get_counter_roles()?;
                
                let role_rc = roles_vec.get(index)
                    .ok_or(MbtError::other(format!("{}Role instance not found at index {}", "Counter", index)))?;

                match function_name {
                    
                    "Inc" => role_rc.action_inc(args).await,
                    "Get" => role_rc.action_get(args).await,
                    "Dec" => role_rc.action_dec(args).await,
                    _ => Err(MbtError::other(
                        format!("Unknown action '{}' for CounterRole", function_name)
                    )),
                }
            }
            
            
            // Top-level actions (role_id.role_name is expected to be empty for top-level)
            "" => {
                match function_name {
                    
                    _ => Err(MbtError::other(
                        format!("Unknown top-level action: '{}'", function_name)
                    )),
                }
            }

            _ => Err(MbtError::other(format!("Unknown role: {}", role_id.role_name))),
        }
    }
    
    fn get_roles(&self) -> Result<Vec<RoleId>, MbtError> {
        let inner_model_ref = self.model.as_ref().ok_or_else(|| {
            MbtError::other("Model is not initialized or has been moved out of the dispatcher.")
        })?;
        
        let mut all_role_ids = Vec::new();

        // Collect all role IDs
        
        {
            let roles = inner_model_ref.get_counter_roles()?;
            let role_ids: Vec<RoleId> = roles.iter()
                .enumerate()
                .map(|(index, _)| RoleId {
                    role_name: "Counter".to_string(), 
                    index: index as i32,
                })
                .collect();
            all_role_ids.extend(role_ids);
        }
        
        
        Ok(all_role_ids)
    }
}

// Use a runtime test macro to allow async operations inside the test function
#[test]
fn test_counter_model() -> Result<(), MbtError> {
    let model = new_counter_model(); 
    
    let dispatcher = CounterActionDispatcher::new(model); 
    
    // Executes model-based test traces.
    fizzbee_mbt::run_mbt_test(dispatcher, get_test_options())?;
    
    Ok(())
}