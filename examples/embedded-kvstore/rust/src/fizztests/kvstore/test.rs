// Code generated by fizzbee-mbt generator; DO NOT EDIT.

// Import the generated traits, adapters, and framework utilities
use super::traits::*;
use super::adapters::{new_embedded_kvstore_model, get_test_options};

use fizzbee_mbt::traits::*;
use fizzbee_mbt::types::*;
use fizzbee_mbt::value::*;
use fizzbee_mbt::error::MbtError;
use async_trait::async_trait;

/// The Dispatcher routes actions from the MBT framework to the correct Role/Model instance.
/// It wraps the concrete Model implementation.
pub struct EmbeddedKvstoreActionDispatcher<T>
where
    T: EmbeddedKvstoreModel + Send + Sync + 'static,
{
    // The concrete model instance is owned directly
    model: Option<T>,
}

#[async_trait]
impl<T> Model for EmbeddedKvstoreActionDispatcher<T>
where
    T: Model + EmbeddedKvstoreModel + Send + Sync + 'static,
{
    /// Delegates initialization to the inner model instance.
    async fn init(&mut self) -> Result<(), MbtError> {
        self.model.as_mut().ok_or_else(|| MbtError::other("Model not found"))?
            .init().await
    }

    /// Delegates cleanup to the inner model instance.
    async fn cleanup(&mut self) -> Result<(), MbtError> {
        self.model.as_mut().ok_or_else(|| MbtError::other("Model not found"))?
            .cleanup().await
    }
}

impl<T> EmbeddedKvstoreActionDispatcher<T>
where
    T: EmbeddedKvstoreModel + Send + Sync + 'static,
{
    pub fn new(model: T) -> Self {
        EmbeddedKvstoreActionDispatcher {
            model: Some(model),
        }
    }
}

/// Implementation of the framework's core execution contract (`DispatchModel`).
#[async_trait]
impl<T> DispatchModel for EmbeddedKvstoreActionDispatcher<T>
where
    T: EmbeddedKvstoreModel,
    T: Send + Sync + 'static,
{
    async fn execute(
        &self,
        role_id: &RoleId,
        function_name: &str,
        args: &[Arg],
    ) -> Result<Value, MbtError> {

        let inner_model_ref = self.model.as_ref().ok_or_else(|| {
            MbtError::other("Model is not initialized or has been moved out of the dispatcher.")
        })?;

        match role_id.role_name.as_str() {
            // Role actions
            
            "Writer" => {
                let index = role_id.index as usize;

                let roles_vec = inner_model_ref.get_writer_roles()?;

                let role_rc = roles_vec.get(index)
                    .ok_or(MbtError::other(format!("{}Role instance not found at index {}", "Writer", index)))?;

                match function_name {
                    "Put" => role_rc.action_put(args).await,"Get" => role_rc.action_get(args).await,"Flush" => role_rc.action_flush(args).await,
                    _ => Err(MbtError::other(
                        format!("Unknown action '{}' for WriterRole", function_name)
                    )),
                }
            }
            
            "Storage" => {
                // Role Storage has no actions (other than Init), so any call is an error.
                Err(MbtError::other(
                    format!("Role Storage has no actions, function '{}' is invalid", function_name)
                ))
            }
            

            // Top-level actions (role_id.role_name is expected to be empty for top-level)
            "" => {
                match function_name {
                    
                    _ => Err(MbtError::other(
                        format!("Unknown top-level action: '{}'", function_name)
                    )),
                }
            }

            _ => Err(MbtError::other(format!("Unknown role: {}", role_id.role_name))),
        }
    }

    fn get_roles(&self) -> Result<Vec<RoleId>, MbtError> {
        let inner_model_ref = self.model.as_ref().ok_or_else(|| {
            MbtError::other("Model is not initialized or has been moved out of the dispatcher.")
        })?;

        let mut all_role_ids = Vec::new();

        // Collect all role IDs
        
        {
            let roles = inner_model_ref.get_writer_roles()?;
            let role_ids: Vec<RoleId> = roles.iter()
                .enumerate()
                .map(|(index, _)| RoleId {
                    role_name: "Writer".to_string(),
                    index: index as i32,
                })
                .collect();
            all_role_ids.extend(role_ids);
        }
        
        {
            let roles = inner_model_ref.get_storage_roles()?;
            let role_ids: Vec<RoleId> = roles.iter()
                .enumerate()
                .map(|(index, _)| RoleId {
                    role_name: "Storage".to_string(),
                    index: index as i32,
                })
                .collect();
            all_role_ids.extend(role_ids);
        }
        

        Ok(all_role_ids)
    }
}

// Use a runtime test macro to allow async operations inside the test function
#[test]
fn test_embedded_kvstore_model() -> Result<(), MbtError> {
    let model = new_embedded_kvstore_model();

    let dispatcher = EmbeddedKvstoreActionDispatcher::new(model);
    
    // Executes model-based test traces.
    fizzbee_mbt::run_mbt_test(dispatcher, get_test_options())?;
    
    Ok(())
}